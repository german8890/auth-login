package logging

import (
	"context"

	"autenticacion-ms/cmd/entity"

	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
)

const (
	RequestIDKey contextKey = iota
	Test
)

// Logger is a logger that supports log levels, context and structured logging.
type Logger interface {
	// With returns a logger based off the root logger and decorates it with the given context and arguments.
	With(ctx context.Context, fields ...Field) Logger

	// Debug uses fmt.Sprint to construct and log a message at DEBUG level
	Debug(msg string, fields ...Field)
	// Info uses fmt.Sprint to construct and log a message at INFO level
	Info(msg string, fields ...Field)
	// Error uses fmt.Sprint to construct and log a message at ERROR level
	Error(msg string, fields ...Field)
	// Warn uses fmt.Sprintf to construct and log a message at Warn level
	Warn(msg string, fields ...Field)
	// DPanic uses fmt.Sprintf to construct and log a message at DPanic level
	DPanic(msg string, fields ...Field)
	// Panic uses fmt.Sprintf to construct and log a message at Panic level
	Panic(msg string, fields ...Field)
	// Fatal uses fmt.Sprintf to construct and log a message at Fatal level
	Fatal(msg string, fields ...Field)
}

type logger struct {
	*zap.Logger
}

func (l *logger) Debug(msg string, fields ...Field) {
	l.Logger.Debug(msg, toFieldZap(fields...)...)
}

func (l *logger) Info(msg string, fields ...Field) {

	l.Logger.Info(msg, toFieldZap(fields...)...)
}

func (l *logger) Error(msg string, fields ...Field) {
	l.Logger.Error(msg, toFieldZap(fields...)...)
}

func (l *logger) Warn(msg string, fields ...Field) {
	l.Logger.Warn(msg, toFieldZap(fields...)...)
}

func (l *logger) DPanic(msg string, fields ...Field) {
	l.Logger.DPanic(msg, toFieldZap(fields...)...)
}

func (l *logger) Panic(msg string, fields ...Field) {
	l.Logger.Panic(msg, toFieldZap(fields...)...)
}

func (l *logger) Fatal(msg string, fields ...Field) {
	l.Logger.Fatal(msg, toFieldZap(fields...)...)
}

type contextKey int

func (l *logger) Check(entry zapcore.Entry, checked *zapcore.CheckedEntry) *zapcore.CheckedEntry {
	if l.Logger.Core().Enabled(entry.Level) {
		return checked.AddCore(entry, l.Logger.Core())
	}
	return checked
}

// New creates a new logger using the default configuration.
func New(levelLogging string) *logger {
	err := zap.RegisterEncoder("duplicate-caller", func(config zapcore.EncoderConfig) (zapcore.Encoder, error) {
		return &duplicateCallerEncoder{Encoder: zapcore.NewJSONEncoder(config)}, nil
	})
	// it's reasonable to panic here, since the program can't initialize
	if err != nil {
		panic(err)
	}
	l, _ := ConfigureLogger(levelLogging)
	ConfigVarGlobalLogger()

	l = l.With(toFieldZap(AnyField("service", Service))...)
	return &logger{l}
}

// NewForTest creates a new logger using the default configuration.
func NewForTest(levelLogging string) *logger {

	// it's reasonable to panic here, since the program can't initialize

	l, _ := ConfigureLogger(levelLogging)
	ConfigVarGlobalLogger()

	//l = l.With(toFieldZap(AnyField("service", Service))...)
	return &logger{l}
}

func (l *logger) WithPattern(pattern map[string]interface{}) *logger {
	if len(pattern) >= 0 {
		for key, value := range pattern {
			l.Logger = l.Logger.With(zap.Any(key, value))
		}
	}
	return l
}

// With returns a logger based off the root logger and decorates it with the given context and arguments.
//
// If the context contains request ID and/or correlation ID information (recorded via WithRequestID()
// and WithCorrelationID()), they will be added to every log message generated by the new logger.
//
// The arguments should be specified as a sequence of name, value pairs with names being strings.
// The arguments will also be added to every log message generated by the logger.
func (l *logger) With(ctx context.Context, fields ...Field) Logger {

	if ctx != nil {
		if id, ok := ctx.Value(country).(string); ok {
			fields = append(fields, AnyField("country", id))
		}
		if id, ok := ctx.Value(consumerRef).(string); ok {
			fields = append(fields, AnyField("consumerRef", id))
		}
		if id, ok := ctx.Value(channelRef).(string); ok {
			fields = append(fields, AnyField("channelRef", id))
		}
		if id, ok := ctx.Value(brand).(string); ok {
			fields = append(fields, AnyField("brand", id))
		}
		if id, ok := ctx.Value(storeRef).(string); ok {
			fields = append(fields, AnyField("storeRef", id))
		}
		if id, ok := ctx.Value(env).(string); ok {
			fields = append(fields, AnyField("environment", id))
		}
		if id, ok := ctx.Value(consumerDateTime).(string); ok {
			fields = append(fields, AnyField("consumerDateTime", id))
		}
		if id, ok := ctx.Value(processRef).(string); ok {
			fields = append(fields, AnyField("processRef", id))
		}
		if id, ok := ctx.Value(userTrx).(string); ok {
			fields = append(fields, AnyField("userTrx", id))
		}
		if id, ok := ctx.Value(groupId).(string); ok {
			fields = append(fields, AnyField("groupId", id))
		}
		if id, ok := ctx.Value(operationId).(string); ok {
			fields = append(fields, AnyField("operationId", id))
		}

		if id, ok := ctx.Value(typeProduct).(string); ok {
			fields = append(fields, AnyField("typeProduct", id))
		}

		if id, ok := ctx.Value(typeProcessRef).(string); ok {
			fields = append(fields, AnyField("typeProcessRef", id))
		}

		if id, ok := ctx.Value(traceId).(string); ok {
			var trace = &entity.Trace{}
			fields = append(fields, AnyField("traceId", id))
			trace.Id = id
			if id2, ok2 := ctx.Value(spanId).(string); ok2 {
				fields = append(fields, AnyField("spanId", id2))
				trace.Span = id2
			}
			fields = append(fields, AnyField("trace", trace))
		}
	}

	//fields = append(fields, AnyField("service", Service))
	if len(fields) > 0 {
		return &logger{l.Logger.With(toFieldZap(fields...)...)}
	}
	return l
}
